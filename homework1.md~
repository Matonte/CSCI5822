    
    
    
Michael Matonte
CSCI 5822
1.22.17
Homework 1

# **1 – Essential Difficulties**
    Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.


# 1 Answer
An essential difficulty is a factor in some activity that makes it hard. The saying “its a feature, not a bug” comes to mind. Essential difficulties will always occur with an activity without substantially changing the nature of the activity. An example of an essential difficulty would be the need to produce enough lift from wind resistance in flight to overcome gravity. This always has and will always limit aircraft building an design.


# **2 – Accidental Difficulties**
    Define the term accidental difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.

# 2 Answer
    An accidental difficulty is a factor that only exists simply because of a way the activity is currently being performed. Accidental difficulties can be removed from an activity without it changing the nature or goals of an activity. An example of an accidental difficulty would be that in athletics, there are cost or availability constraints in nutrition. This difficulty could be overcome by learning about inexpensive supplements or pre-made meals.

# **3 – Brooks’ Essential Difficulty**
    List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties. The four essential difficulties he talked about are Complexity, Changeability, Conformity, and Invisibility.

# 3 Answer 
*Complexity* is where difficulty develops from all the parts and relationships that have to be managed for effective delivery. This is usually complicated by external and non- technical considerations that influence the delivery. An example of Complexity in a non- technical world could be the current negotiations in Government where you not only have to deal with different immediately perceived demands from the actors, but also with the fluidity and long-term concerns of the actors' needs.


*Changeability* is where difficulty develops from not just current complexities needing to be resolved, but also the fact that clients don't know or never appear to know what they want and so the requirements are in constant flux and beyond that, the technology is in constant flux and competitors are always trying to do something new as well. This is all on top of the tendency for the environment in this software programs never being the same. An example of the difficulty of

*Changeability* would be that not only might the client change, but even if the client remains the same, the client's demands and policies might change. Imagine being a Government contractor in the time immediately before and after a consequential election!


*Conformity* is a difficulty that is inherent in professional intellectual activity in general. Not only does your solution have to be factually correct, but must be accepted by the user whether or not it is entirely correct in fact. An example of Conformity causing a delay could be where a web application is very well written and functions just as the user demands but is noneoftheless refused because it is done in green- blue graphics instead of blue-green graphics because the developer in charge of writing the program never knew about the change in color scheme.


*Invisibility* is a unique essential difficulty to Software Engineering compared to many other Engineering disciplines. The very fact that you cannot create a literal visualization of the program beyond simple object or activity diagrams makes understanding what you are ultimately working towards more difficult. Any data structure, control structure, or method doesn't actually really exist anywhere. You simply type such things up, compile or build them and check that their behavior at run time is same the behavior your flow charts and diagrams show that they should have. The data structure should have its text read through an API to a GUI and display those text contents on the screen. Because of them, only abstract representations of results can be shown as the actual artifacts are simply instructions to the patterns a computer's transistors will fire to create a certain behavior.

# ** 4 “No Silver Bullet” ** 
    Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering.

# Answer 
Literally, Brooks means that there will never be anything new in Software Engineering that alone with make it ten times easier. Seriously, he argues that there is simply no one thing you can do to make things much easier in a way that would substantially change the nature of Software Engineering, His argument for why this is the case is simply that there are so many factors that are inherently difficult in Software Engineering that there is not a single thing that can overcome enough of these difficulties at once to make Software Engineering much easier that it is.

# ** 5 The Scientists and the Engineers **
    In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.

# Answer
Chemists are those who study the matter in the universe and attempt to learn more about the details and factual explanations for its existence and behavior. Chemical Engineers take the information about what Chemists have learned and try to leverage that knowledge into something that can be applied in a way that solves a real world problem. The desalinization problem given in lecture was interesting. The Chemists proves that desalinization is a natural process, but it is up to the Chemical Engineer to leverage that in a way that can solve the practical problems that can be solved with desalinization.

This analogy applied to Computer Science would be that a Computer Scientist studies the details and factual explanation of how information exists in the universe while the Software Engineer finds and solves problems using that knowledge. An example of this could be how a Software Engineer designs a program to access shared files in a quick manner with a tree data-structure that a Computer Scientists has theorized.


# ** 6- The Lecture Terms **
    In lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.
```

# Answer
The concept of *iteration* is important because in modern Software Engineering, things are complex and have to be done bit after bit in order to ever become “done” and further modern Engineering Management, there is always the objective of being able to come up with something quickly and steadily improve the product until it is ready for deployment.


The concept of *abstractions* is that we have some sort of concrete way of expressing or using abstract ideas. An example of this is to find a way to articulate commands or expressions in a way that a computer and compiler can understand. This is important because it allows Computer Science to translate into Software Engineering.


The notion of *conversations* is that there is a dynamic and constant stream of consideration between the various parties who are performing or procuring the Software Engineering artifacts. This is important because of the changing needs and the seeming arbitrary human factors of Software Engineering require constant attention as the Software Engineering artifact is being cultivated so that it can be accepted and usable to the procurers.


*Translation* to me is a more general level of abstraction, however on a human level. Where abstraction is about how machines can apply abstract ideas, translation is how people abstract between what can be understood by developers and what can be understood by product owners. An example of this are the graphical representations that you would make to take vague requirements, solidify them into something that is readable so that the work produced is what is as close to the original concepts of the people who had ordered to software be written.

*Specification* is a specific type of translation. It allows for the articulation of requirements so that the software can be developed in a way that will be accepted. Developers need to know what exactly they are working on and to a point, how they are to be done. Without this Specification, developers would simply have to hope this is what their clients are looking for. 
